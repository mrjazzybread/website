<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Research Notes</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css" />
</head>
<body>
<div id="content" class="content">
<h1 class="title">Research Notes</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org4fa9525">Type declarations</a></li>
<li><a href="#org961af59">Value descriptions</a></li>
<li><a href="#orgedb52db"><code>Prop</code> and <code>Bool</code></a></li>
<li><a href="#orgc5d0281">Gospel Type Semantics</a></li>
<li><a href="#orgedf297f">Higher order spatial types</a></li>
<li><a href="#org056f9bf">Lemmas</a></li>
<li><a href="#org5464b7f">Open Questions</a></li>
<li><a href="#org92611aa">Exceptional Specifications</a></li>
<li><a href="#orgaa7af05">Functor Constraints</a></li>
<li><a href="#orgfe9fd3e">Miscellaneous changes</a></li>
<li><a href="#org761509f">Updated syntax</a></li>
<li><a href="#org2a054f1">Shared Resources</a></li>
</ul>
</div>
</div>

<div id="outline-container-org4fa9525" class="outline-2">
<h2 id="org4fa9525">Type declarations</h2>
<div class="outline-text-2" id="text-org4fa9525">
<p>
When translating a type declaration into separation logic, we have to
create, besides the type definition, a representation predicate that
receives a program variable and lifts it into a logical
representation. This logical representation is defined using the <code>model</code>
field in the type specification.
</p>
</div>

<div id="outline-container-org1bd4af5" class="outline-3">
<h3 id="org1bd4af5">Unnamed Model Fields</h3>
<div class="outline-text-3" id="text-org1bd4af5">
<p>
One of the changes we made to the <b>Gospel</b> typechecker was allowing
<code>model</code> fields to be unnamed. For example, if we wish to specify a queue
in current gospel whose logical model is a <code>sequence</code>, we must write as
such.
</p>
<pre class="example" id="org39aae74">
type t
(*@ model view : int sequence *)

val push : t -&gt; int -&gt; unit 
(*@ push q x
    ensures q.view = old q.view ++ [x] *)
</pre>
<p>
Although the model of the queue is the only thing that interests us in
this specification (and indeed, most specifications) we still have to
access it via the field <code>view</code>. This can not only be cumbersome but also
make specifications more verbose than they need be. Although the
example above is still valid in <b>Gospel</b>, we have developed an alternate
syntax for cases where types only have a single <code>model</code> field.
</p>
<pre class="example" id="org5054d2f">
type t
(*@ model : int sequence *)

val push : t -&gt; int -&gt; unit
(*@ push q x
    ensures q = old q ++ [x] *)
</pre>
<p>
In the second code snippet, <code>q</code> in the specification has the same type
as its model field. This way, the specification becomes a bit easier
to write and read.
</p>
</div>
</div>

<div id="outline-container-org468a3f0" class="outline-3">
<h3 id="org468a3f0">Multiple Model Fields</h3>
<div class="outline-text-3" id="text-org468a3f0">
<p>
When creating the representation predicate for a type with multiple
<code>model</code> fields, we have the option between creating a predicate with
multiple fields for the logical values or creating a record type with
each field described in the specification. I believe that the sanest
way to do this is by using ghost record type. This is because multiple
fields can make the translation more illegible, as well as more
difficult to execute, seeing as I would have to replace all
occurrences of model field accesses as well as manage potential
problems with clashing names.
</p>

<p>
Example (assuming <code>x</code> is of type <code>t</code> with two model fields <code>y</code> and <code>z</code>) :
</p>
<pre class="example" id="org0205d5c">
(*@ f x y z
    ensures x.y + y = z *)
</pre>
<p>
would become, during translation
</p>
<div class="equation*" id="org63651f9">
<p>
{}(f(x, y, z)){P(x, y, z) * y + y = z}
</p>

</div>
<p>
While typing, I assume just one type and, in the specification, handle
the model fields as <code>ghost</code> fields (which is already the default
behaviour). While translating to separation logic, I create two types,
one for the program type and another for the model.
</p>
</div>
<div id="outline-container-org32007d0" class="outline-4">
<h4 id="org32007d0">Naming problems</h4>
<div class="outline-text-4" id="text-org32007d0">
<p>
The tricky question to solve however is what names to give these
types? I think the easiest solution is to give the logical type
the same name as the <b>OCaml</b> type and give the program type the same
name, but with an underscore at the beginning. This way, we don't have
to change anything in the typed specification.
</p>
</div>
</div>
</div>
<div id="outline-container-org60b7389" class="outline-3">
<h3 id="org60b7389"><a id="orgc578560"></a>Ephemeral and Pure Annotations</h3>
<div class="outline-text-3" id="text-org60b7389">
<p>
It is also possible to not give the type a <code>model</code> field and instead opt
to give an <code>ephemeral</code> annotation as such
</p>
<pre class="example" id="org113df92">
type t
(*@ ephemeral *)
</pre>
<p>
This way, we can mark the type as mutable without giving a precise
definition of its logical representation. If the type has no
annotations, then we assume it to be pure and its model is a
reflection of the <b>OCaml</b> type.
</p>
</div>
</div>
<div id="outline-container-org862a136" class="outline-3">
<h3 id="org862a136">Representation Predicates</h3>
<div class="outline-text-3" id="text-org862a136">
<p>
As stated previously, when we translate a type declaration, we also
need to generate an appropriate representation predicate. How we do so
depends on how the type is defined.
</p>
</div>

<div id="outline-container-org8f28905" class="outline-4">
<h4 id="org8f28905">Abstract Types</h4>
<div class="outline-text-4" id="text-org8f28905">
<p>
Since we cannot give a representation predicate to a type that is
undefined in the program, we simply create its signature. This
predicate will have two arguments, the program value and the logical
representation, that is, the type defined in its <code>model</code> clause.
</p>
<ul class="org-ul">
<li>If the type is pure, then the program value is the same as the <b>OCaml</b>
type. In the case where the <code>model</code> is a reflection of the <b>OCaml</b> type
as described in Section <a href="#orgc578560">Ephemeral and Pure Annotations</a>, no
representation predicate is generated</li>
<li>If the type is mutable, then the program value is of type <code>loc</code>.</li>
</ul>
</div>
</div>
<div id="outline-container-org68125f4" class="outline-4">
<h4 id="org68125f4">Concrete Types</h4>
<div class="outline-text-4" id="text-org68125f4">
<p>
TBD
</p>
</div>
</div>

<div id="outline-container-orgd110678" class="outline-4">
<h4 id="orgd110678">Note on naming</h4>
<div class="outline-text-4" id="text-orgd110678">
<p>
Generally, the generated representation predicate has the same name
as the original type, but with the first letter capitalized and an
underscore at the start. However, when the type's name is <code>t</code>, the
representation predicate gets the same name as the name of the module,
so as to make the generated Separation Logic triples simpler to read.
</p>
</div>
</div>
</div>
<div id="outline-container-orgf8668cb" class="outline-3">
<h3 id="orgf8668cb">Translation of Type declarations</h3>
<div class="outline-text-3" id="text-orgf8668cb">
<pre class="example" id="org11b1ca1">
type t
(*@ model : int *)
</pre>
<p>
Translates into 
</p>
<pre class="example" id="orgf3c6018">
Type t
Predicate _T (target : t) (model : int)
</pre>
<pre class="example" id="orga65f7df">
type t
(*@ mutable model : int *)
</pre>
<p>
Translates into
</p>
<pre class="example" id="org9a8fa4c">
Predicate _T (target : loc) (model : int)
</pre>
<pre class="example" id="org049028b">
type t
(*@ model x : int
    model y : int *)
</pre>
<p>
Translates into
</p>
<pre class="example" id="org10c4c56">
Type t = {x : int; y : int}
Type _t

Predicate _T (target : t) (model : _t)
</pre>
<pre class="example" id="org895f72f">
type t
(*@ mutable model x : int
    model y : int
*)
</pre>
<p>
Translates into
</p>
<pre class="example" id="org353b7b4">
Type t = {x : int; y : int}
Predicate _T (target : loc) (model : t)
</pre>
</div>
</div>
<div id="outline-container-orgaf669cb" class="outline-3">
<h3 id="orgaf669cb">Implementation</h3>
<div class="outline-text-3" id="text-orgaf669cb">
<ol class="org-ol">
<li>Check if the type has a specification. If so, retrieve the model,
if not, assume the model is a reflection of the OCaml type.</li>
<li>We must check if the type has multiple model fields. If so, we
create an optional value that has the definition of a record type
with all these fields. This type is always marked is
non-mutable. The name of this type is the same as the name of the
original type.</li>
<li>We create a definition of the type. The name of this type depends
if we created a record in the previous step. If so, the name is the
old name with an underscore at the start. Otherwise, the name is
unchanged. For now, we only support abstract types.</li>
<li>We create the definition for the representation predicate. If the
type is mutable, the first argument is of type <code>loc</code>, otherwise, the
first argument is the program type. The next argument is the type's
model, as was defined previously.</li>
</ol>
</div>
</div>
<div id="outline-container-org2b9276c" class="outline-3">
<h3 id="org2b9276c">Limitations</h3>
<div class="outline-text-3" id="text-org2b9276c">
<ul class="org-ul">
<li>When translated into <b>CFML</b>, record fields with names that have
already been defined don't work (Low priority).</li>
<li>No support for polymorphic types with recursive ownership.</li>
<li>No support for concrete type definitions. This can be quite tricky
since in these cases we would need to define an explicit
representation predicate in <b>Gospel</b>, which is not yet possible.
<ul class="org-ul">
<li>Additionally, we must consider the relationship between invariants
and representation predicates.</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org961af59" class="outline-2">
<h2 id="org961af59">Value descriptions</h2>
<div class="outline-text-2" id="text-org961af59">
<p>
When translating a value description and, more importantly,
specification, we must take proper care to ensure that all the
ownership conditions are properly generated and are semantically
equivalent to their <b>Gospel</b> counterparts.
</p>
</div>
<div id="outline-container-orgcd93a6f" class="outline-3">
<h3 id="orgcd93a6f">Spatial Types</h3>
<div class="outline-text-3" id="text-orgcd93a6f">
<p>
To describe ownership of values, we use what are called <i>Spatial Types</i>;
lightweight notation to encode representation predicates. For example,
let us assume once again a queue whose logical <code>model</code> is a sequence of
integers:
</p>
<pre class="example" id="orgcd436e4">
type t
(*@ mutable model : int sequence *)

val push : t -&gt; int -&gt; unit
(*@ f q x
    modifies q
    ensures q = q ++ [x]*)
</pre>
<p>
As I stated in the previous section, the variable <code>q</code> has type <code>int
sequence</code> in the specification. However, in the <b>OCaml</b> interface, it has
type <code>t</code>. To make this transition, we require a representation predicate
(in <b>Gospel</b>'s case, a spatial type) that lifts the program value into
its logical value. In this case, we could write
</p>
<pre class="example" id="orgafc6064">
val push : t -&gt; int -&gt; unit
(*@ f q x
    modifies q @ t
    ensures ... *)
</pre>
<p>
The <code>modifies</code> clause states that we receive ownership of the <b>OCaml</b>
variable <code>q</code> using the spatial type <code>t</code> and lift it into the logical type
stated in <code>t</code>'s model, that is, a sequence of integers. When we use the
spatial type with the same name as the original type (which we will
refer to as the <i>default spatial type)</i>, we say that we have full
ownership of that value. Additionally, the <code>modifies</code> clause also states
that we return the same ownership of <code>q</code>. Given these semantics, we
could translate this specification into the following Separation Logic
triple (in <b>CFML</b> syntax for simplicity's sake).
</p>
<pre class="example" id="org9f25648">
forall (prog_q : loc) (q : int list) (x : int)
PRE (prog_q ~&gt; Queue q)
POSTUNIT (prog_q ~&gt; Queue (q ++ [x]))
</pre>
<p>
Important to note that spatial types are not exclusive used in
specifications as we see in the Section on <a href="#orgdc0caac">Logical Quantifiers</a>,
however, we will mostly focus on this use case as it is the most
common as well as the simplest.
</p>
</div>
</div>

<div id="outline-container-org55e30e6" class="outline-3">
<h3 id="org55e30e6">Ownership clauses</h3>
<div class="outline-text-3" id="text-org55e30e6">
<p>
To describe ownership with spatial types, we can use one of the
following clauses:
</p>
<ul class="org-ul">
<li><code>consumes x @ t</code>: states that the function receives ownership of a
value <code>x</code> as described by the representation predicate <code>t</code>.</li>
<li><code>produces x @ t</code>: states that the function returns ownership of a
value <code>x</code> as described by the representation predicate <code>t</code>.</li>
<li><code>modifies x @ t</code>: states that the function receives and returns
ownership of a value <code>x</code> as described by the representation predicate
<code>t</code>. Note that <b>Gospel</b> treats this clause as syntactic sugar for a
<code>consumes</code> and <code>produces</code> clause.</li>
<li><code>preserves x @ t</code>: states that the function receives and returns
ownership of a value <code>x</code> as described by the representation predicate
<code>t</code>. Note that this is syntactic sugar for a <code>produces</code> and <code>consumes</code>
clause coupled with an <code>ensures</code> clause stating that <code>x</code> is unchanged.</li>
</ul>

<p>
If no ownership clause is defined for a function argument, then <b>Gospel</b>
assumes a <code>preserves</code> clause with full ownership. In the case of return
values, we assume a <code>produces</code> with full ownership.
</p>
</div>
</div>
<div id="outline-container-org3155585" class="outline-3">
<h3 id="org3155585">Available Spatial Types</h3>
<div class="outline-text-3" id="text-org3155585">
<p>
For now, besides the default spatial type, we only have access to two
spatial types:
</p>
<ul class="org-ul">
<li>The <code>val</code> spatial type, that gives us no ownership of a value</li>
<li><p>
The <code>loc</code> spatial type, that gives us no ownership of a value, which
can only be used for mutable values. The reason why there are two
different spatial types that have similar purposes is to specify
functions that feature physical equality. For example, due to how
physical equality is defined in <b>OCaml</b>, it may be desirable to define
it only for the case when it receives two memory locations. To do
this, we can state:
</p>
<pre class="example" id="orgd8b7723">
val ph_eq : 'a -&gt; 'a -&gt; bool
(*@ ph_eq x y
    preserves x @ loc, y @ loc
    ensures x = y *)
</pre>
<p>
This way, this function can only be called with values with which we
can apply the spatial type <code>loc</code>, in other words, mutable values.
</p></li>
</ul>
</div>
</div>
<div id="outline-container-org2e3e0fc" class="outline-3">
<h3 id="org2e3e0fc">Limitations</h3>
<div class="outline-text-3" id="text-org2e3e0fc">
<ul class="org-ul">
<li>No support for polymorphic spatial types, in other words, higher
order representation predicates.</li>
<li>No support for group ownership.</li>
</ul>
</div>
</div>
<div id="outline-container-orgc134e9d" class="outline-3">
<h3 id="orgc134e9d">Translations of Spatial Types</h3>
<div class="outline-text-3" id="text-orgc134e9d">
<p>
This section will showcase some simple examples of how spatial types
are translated into Separation Logic. To showcase, I will show an
example of a stack module, its <b>Gospel</b> specification and its <b>CFML</b>
translation. 
</p>
<pre class="example" id="org3228dac">
type 'a t
(*@ mutable model : 'a Sequence.t *)
</pre>
<p>
Translates into
</p>
<pre class="example" id="org5fc64cf">
Parameter Stack :
forall A {Ih : Inhab A} {EA : Enc A},
sequence A -&gt; loc -&gt; hprop
</pre>
<p>
A few details about this translation:
</p>
<ul class="org-ul">
<li>The type definition is omitted in the final <b>Coq</b> code and only the
representation predicate remains. This is because the type is
mutable which is not allowed in our Separation Logic
encoding.</li>
<li>When defining the representation predicate, we also state that the
type argument <code>A</code> is inhabited, an assumption that <b>Gospel</b>
makes. Additionally, we also state that the type can be encoded in
<b>OCaml</b>. The first assumption is made for all type arguments whereas
the later is only made for type arguments of <b>OCaml</b> functions.</li>
<li>The first argument of the predicate is the logical model, the second
argument is the <b>CFML</b> type for memory locations. Its return is a
separation logic proposition.</li>
<li>The name of the representation predicate (<code>Stack</code>) is automatically
inferred from the module name.</li>
</ul>
<pre class="example" id="orgcef9d71">
val create : unit -&gt; 'a t
(*@ q = create ()
    ensures q = empty *)
</pre>
<pre class="example" id="orgc7e3e82">
Parameter _create : CFML.Semantics.val.

Parameter _create_spec:
  forall (A : Type) (Ih : Inhab a) (EA : Enc a),
  SPEC_PURE (_create tt)
    POST (fun _prog_q : loc =&gt; _prog_q ~&gt; Stack_cfml empty)
</pre>
<p>
A few more details
</p>
<ul class="org-ul">
<li>Since the original specification does not have any ownership clauses
that reference the return value, we assume <code>produces q @ t</code>.</li>
<li>Just like in the original program, we create an abstract function
definition as well as a triple.</li>
<li>The <code>create</code> specification returns a variable <code>_prog_q</code> which is not
present in the original specification. This is because the <code>q</code>
return value represents the logical model of the stack, whereas
<code>_prog_q</code> represents its memory location, which is not explicitly
defined in the <b>Gospel</b> side.</li>
<li>Interestingly, the <code>q</code> variable is not present in the generated
specification. This is because in this case the <b>Gospel</b> specification
can be captured without it, although there are cases where it must
be defined via existential quantification.</li>
</ul>
<pre class="example" id="org03a86fc">
val is_empty : 'a t -&gt; bool
(*@ b = is_empty q
    ensures b &lt;-&gt; q = empty *)
</pre>
<p>
Translates into:
</p>
<pre class="example" id="org4a8cc05">
Parameter _is_empty : CFML.Semantics.val.

Parameter _is_empty_spec : 
  forall (A : Type) (IH : Inhab a) (EA : Enc a) 
    (_prog_q : loc) (q : sequence a),
  SPEC (_is_empty _prog_q)
  PRE _prog_q ~&gt; Stack_cfml q
  POST (fun _prog_b : bool =&gt;
        _prog_q ~&gt; Stack_cfml q \* _prog_b ~&gt; Bool (q = empty))
</pre>
<p>
More details:
</p>
<ul class="org-ul">
<li>Since the <b>Gospel</b> specification does not have any ownership clauses
regarding the variable <code>q</code>, we assume <code>preserves @ t</code>.</li>
<li>Since the <code>q</code> variable is unmodified and its ownership is preserved,
we use the representation predicate in both the pre and post
conditions to claim ownership.</li>
<li>The <code>Bool</code> representation predicate allows us to jump from the <b>OCaml</b>
<code>bool</code> type to the <b>Coq</b> <code>Prop</code> type.</li>
</ul>
<pre class="example" id="org04e4c2e">
val push : 'a t -&gt; 'a -&gt; unit
(*@ push p x
    modifies p
    ensures p = cons x (old p) *)
</pre>
<p>
Translates into:
</p>
<pre class="example" id="org62cfe65">
Parameter _push : CFML.Semantics.val.

Parameter _push_spec :
  forall (a : Type) (aIh : Inhab a) (Ea : Enc a) 
    (_prog_p : loc) (p : sequence a) (x : a),
  SPEC (_push _prog_p x)
  PRE _prog_p ~&gt; Stack_cfml p
  POSTUNIT _prog_p ~&gt; Stack_cfml (cons x p)
</pre>
<pre class="example" id="org8800721">
val pop : 'a t -&gt; 'a
(*@ r = pop p
    modifies p
    raises Not_found
    checks p &lt;&gt; empty
    ensures (old p) = cons r p *)
</pre>
<p>
Translates into:
</p>
<pre class="example" id="org226077f">
Parameter _pop : CFML.Semantics.val.

Parameter _pop_spec :
  forall (a : Type) (aIh : Inhab a) (Ea : Enc a) 
    (_prog_p : loc) (p : sequence a),
  p &lt;&gt; empty -&gt;
  SPEC (_pop _prog_p)
  PRE _prog_p ~&gt; Stack_cfml p
  POST (fun r : a =&gt;
        \exists _p_ : sequence a,
          _prog_p ~&gt; Stack_cfml _p_ \* \[p = cons r _p_])
</pre>
<p>
Some more details:
</p>
<ul class="org-ul">
<li>In the postcondition for this spec, we must explicitly lift the
pointer <code>_prog_p</code> using an existentially quantified variable.</li>
<li>In the original <b>Gospel</b> spec, we have a <code>raises</code> clause stating that
the function raises the <code>Not_found</code> exception, as well as a <code>raises</code>
clause stating that if the stack is not empty, no exception is
raised. Since <b>CFML</b> does not support exceptions, we state that the
generated <b>CFML</b> spec is valid if the stack is not empty.</li>
</ul>
</div>
</div>
<div id="outline-container-org2ece31e" class="outline-3">
<h3 id="org2ece31e"><a id="orgdc0caac"></a> Logical Quantifiers</h3>
<div class="outline-text-3" id="text-org2ece31e">
<p>
If we wish to state a property universal to an <b>OCaml</b> type that cannot
be captured by an invariant, we might find ourselves using an
axiom. However, if we quantify over an <b>OCaml</b> type, we must apply some
spatial type in order to access the model of the value. To give an
example, let's assume we wish to state that all queues are non-empty:
</p>
<pre class="example" id="org7e4129e">
(*@ axiom q_empty : forall q : 'a t, q &lt;&gt; Sequence.empty *)
</pre>
<p>
When translating into Separation Logic, we must ensure that we
correctly apply the representation predicate in order to use its model
to express the desired behaviour. One possible translation is as
follows:
</p>
<pre class="example" id="orgcf185be">
Parameter q_empty :
forall A q_loc (q : sequence A),
  Queue q_loc ~&gt; q -*
  \[q = Sequence.empty] * Queue q_loc ~&gt; q
</pre>
<p>
The general idea is similar to what we saw with specifications: we
create a value of type <code>loc</code> that describes the memory location of the
<b>OCaml</b> value as well as a value with the logical representation of this
value. We also insert an application of a representation predicate
that describes ownership of the value. One of the few changes is that
now we have a separating implication stating that if we have ownership
of the queue, then we can derive the desired property, all the while
remaining with ownership of the value.
</p>
</div>
</div>
</div>
<div id="outline-container-orgedb52db" class="outline-2">
<h2 id="orgedb52db"><code>Prop</code> and <code>Bool</code></h2>
<div class="outline-text-2" id="text-orgedb52db">
<p>
In current <b>Gospel</b>, there is an internal distinction made between
booleans and propositions, although this distinction is not made
apparent to users. As part of my work, I have changed the <b>Gospel</b>
type checker so that this distinction is not made. This makes
translations into <b>CFML</b> a bit trickier since <b>Coq</b> does make an explicit
distinction between the two. For example:
</p>
<pre class="example" id="orgdfe9b68">
function ex (x : bool) (y : bool) =
    true -&gt; x &amp;&amp; y
</pre>
<p>
If we were to translate this term verbatim into <b>Coq</b> we would get a
typing error, since the terms <code>true</code> and <code>x &amp;&amp; y</code> evaluate to booleans
and the <b>Coq</b> implications require values of type <code>Prop</code>. The simplest way
to solve this is by normalizing the resulting <b>Coq</b> program so that all
booleans and boolean related operations are translated into either
<code>Prop</code> or <code>bool</code>. We chose the former since it makes proofs easier to
write, seeing as if all the variables were booleans, we would have to
frequently make explicit conversions to <code>Prop</code>. The downside is that
some cases require somewhat verbose conversions from <code>Prop</code> to <code>bool</code>.
</p>
</div>

<div id="outline-container-org22cd58c" class="outline-3">
<h3 id="org22cd58c">How the translation is done:</h3>
<div class="outline-text-3" id="text-org22cd58c">
<p>
Most cases are quite straightforward: any function arguments of type
<code>bool</code> are turned into <code>Prop</code> and all built in logical symbols are translated
into <code>Coq</code> equivalents that operate on the <code>Prop</code> type. There are a few
details however worth noting:
</p>
</div>

<div id="outline-container-org7b83ff5" class="outline-4">
<h4 id="org7b83ff5">Equality</h4>
<div class="outline-text-4" id="text-org7b83ff5">
<p>
In <b>Gospel</b> the proposition <code>p1 = p2 &lt;-&gt; p1 &lt;-&gt; p2</code> for all <code>p1</code> and
<code>p2</code>. However, in <b>Coq</b>, since we are targeting the <code>Prop</code> type, this is not
valid. Conveniently, <b>CFML</b> uses <b>TLC</b>, which assumes the propositional
extensionality, meaning that the statement above is valid without any
extra configuration. <b>Iris</b> could still be problematic if propositional
extensionality is not assumed.
</p>
</div>
</div>
<div id="outline-container-org71213c5" class="outline-4">
<h4 id="org71213c5">Pattern Matching</h4>
<div class="outline-text-4" id="text-org71213c5">
<p>
Pattern matching over <code>Prop</code> is impossible in <b>Coq</b>, meaning that we must
modify <b>Gospel</b> expressions that use boolean pattern matching so that it
is valid in <b>Coq</b>. Assuming an expression <code>match e with ...</code>, when we
translate into <b>Coq</b>, <code>e</code> will be of type <code>Prop</code>, meaning we must first
transform it into a <code>bool</code>. For example:
</p>
<pre class="example" id="orgd30b3a7">
match true || false with ...
</pre>
<p>
Is translated to:
</p>
<pre class="example" id="org438faf5">
match Prop_to_bool (True \/ False) with ...
</pre>
<p>
In the case where the pattern is a variable name, then we have to
redefine a new variable with the same name but of type <code>Prop</code>. For
example:
</p>
<pre class="example" id="orgbfdf981">
match true with
|x -&gt;  x -&gt; true
</pre>
<p>
Is Translated To:
</p>
<pre class="example" id="org4afe2c5">
match Prop_to_bool True with
|_x -&gt; let x := Prop_to_bool _x in x -&gt; true
end
</pre>
</div>
</div>
<div id="outline-container-orgdb2c1ae" class="outline-4">
<h4 id="orgdb2c1ae">Program Variables</h4>
<div class="outline-text-4" id="text-orgdb2c1ae">
<p>
When we have an <b>OCaml</b> function that receives an argument of type <code>bool</code>,
we cannot simply transform it into an argument of type <code>Prop</code> seeing as
<b>CFML</b> would require an encoder for the <code>Prop</code> type which cannot
exist. Therefore it must remain of type <code>bool</code>, and within the spec must
be turned into a Prop. For example:
</p>
<pre class="example" id="orgdd66608">
val flip : bool -&gt; bool
(*@ r = flip b
    ensures r &lt;-&gt; b *)
</pre>
<p>
Translates to:
</p>
<pre class="example" id="org139b7b2">
forall (_prog_b : bool) (b : Prop),
SPEC(flip _prog_b)
PRE(_prog_b ~&gt; Bool b)
POST(fun _prog_r : bool -&gt; _prog_r ~&gt; Bool b)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc5d0281" class="outline-2">
<h2 id="orgc5d0281">Gospel Type Semantics</h2>
<div class="outline-text-2" id="text-orgc5d0281">
<p>
The semantics of our Separation Logic translation are fairly
straightforward, it has triples, axioms, functions and representation
predicates. However, since the typing discipline is not as obvious, I
will give a little bit of context.
</p>

<p>
All type declarations are pure in the intermediate
representation. When we are faced with an <b>OCaml</b> type that has a
mutable model field, this type disappears from the intermediate
representation, being subsumed into the <code>loc</code> type. Additionally, within
<b>Gospel</b> terms, the user is never allows to refer to any fields or
constructors within the <b>OCaml</b> type and is only allowed to talk about
its logical <code>model</code>, even if the type is pure (unless, of course, if the
model is a reflection of the <b>OCaml</b> type as described in Section <a href="#orgc578560">Pure
Annotations</a>.). If at some point we find it useful to talk about
OCaml values in <b>Gospel</b> terms (e.g. representation predicates) these
semantics might have to be adjusted. One possibility would be to add
"field" declarations similar to what <b>Viper</b> does. This way, we remain
only with pure types but with each of the fields declared.
</p>

<p>
Additionally, all types are assumed to be inhabited. At the moment,
<b>Gospel</b> does not support any construct to create empty types, meaning
it is impossible to generate any inconsistencies.
</p>
</div>
</div>

<div id="outline-container-orgedf297f" class="outline-2">
<h2 id="orgedf297f">Higher order spatial types</h2>
<div class="outline-text-2" id="text-orgedf297f">
<p>
Currently, spatial types are first order, meaning we cannot claim
recursive ownership of polymorphic data types. This greatly limits
their usefulness since we can basically only use them to choose if we
want to claim ownership of a mutable data structure or not. If we
allowed spatial types to be higher order, we could capture in our
specs, for example, containers that store mutable values. This way we
greatly increase the amount of programs <b>Gospel</b> can specify as well as
allowing for a higher level of granularity when describing ownership
conditions.
</p>
</div>
</div>

<div id="outline-container-org056f9bf" class="outline-2">
<h2 id="org056f9bf">Lemmas</h2>
<div class="outline-text-2" id="text-org056f9bf">
<p>
When translating lemmas from <b>Gospel</b> to Separation Logic, I was at
first not making any modifications to them. In other words, they were
treated like pure terms and translated into <b>CFML</b> as normal <b>Coq</b>
terms. However, this is not possible when our lemmas refer to impure
<b>OCaml</b> types since these need to be lifted using Separation Logic
constructors. Naturally, this must be remedied by inserting spatial
types at key locations and properly translating these into Separation
Logic terms.
</p>

<p>
The tricky part is that when we translate terms from Separation Logic
into <b>CFML</b>, we transform them into values of type <code>hprop</code>. This means
that <b>Coq</b> will not require the user to prove that their axioms are
sound. To remedy this, we translate axioms as follows:
</p>
<pre class="example" id="org02315d2">
(*@ axiom A : P *)
</pre>
<pre class="example" id="org60d4b28">
Parameter A : \[] ==&gt; \[P]
</pre>
<p>
Since <code>A</code> is now a <code>Prop</code>, <b>Coq</b> will now require that the user prove its
correctness. Although this will work if the only ownership clauses
refer to variables defined within the lemma, since these only generate
conditions where ownership is only claimed on the left hand side of a
magic wand (see previous section), this will not work if the axiom
refers to global variables. 
 X 
</p>
</div>
</div>
<div id="outline-container-org5464b7f" class="outline-2">
<h2 id="org5464b7f">Open Questions</h2>
<div class="outline-text-2" id="text-org5464b7f">
</div>
<div id="outline-container-org0256e95" class="outline-3">
<h3 id="org0256e95">Impure Types in Logical Terms</h3>
<div class="outline-text-3" id="text-org0256e95">
<p>
As stated previously, when we have a type with multiple <code>model</code>
fields, we create in our intermediate representation a record type
with each field. This record type will then be the model for this
type. However, with the <b>Gospel</b> specification, this type does not
exist, which leaves us with the following question: in the following case:
</p>
<pre class="example" id="org4fdef15">
type t = {ocaml_x : int; ocaml_y : int}
(*@ mutable model x : int
    mutable model y : int *)

val f : t -&gt; unit
(*@ f arg
    ensures arg.x = arg.y *)
</pre>
<p>
What is the type of <code>arg</code> within the specification? The clearest answer
would be that it is of type <code>t</code>, however, type <code>t</code> is an <b>OCaml</b> type. This
is problematic since these may only be used in specifications when
they are pure. Current <b>Gospel</b> allows users to refer to the model
fields and the program fields within the spec. I changed this so that
internally, <code>arg</code> is of type <code>t</code>, but the user is only allowed to access
the model fields <code>x</code> and <code>y</code> and not the fields <code>ocaml_x</code> and <code>ocaml_y</code>. This
way, there is a clear divide between the <b>OCaml</b> and the <b>Gospel</b>
world. Additionally, users may still refer to the model of <code>t</code> in
situations such as:
</p>
<pre class="example" id="orgc527f15">
(*@ predicate test (arg : t) =
    arg.x = arg.y *)
</pre>
<p>
This might be inadequate when we add representation predicates in
<b>Gospel</b> which will require us to access their program fields. A few
alternatives to this would be:
</p>

<ul class="org-ul">
<li>Disallow named model fields and require the user to create an
explicit ghost record type (seems annoying).</li>
<li>Have some special name for the model of <code>t</code>, (seems annoying to
program since finding a naming convention that is both clear and
does not clash with any other names would be quite tricky. Also
seems annoying on the user side that they have to write the name of
a type that does not exist explicitly in the spec)</li>
</ul>


<p>
TODO:
duplicable definition (only needed for CFML)
Lemma duplicable : 
       forall s m,
       Duplicable (s ~&gt; pstack m). 
</p>

<p>
s ~&gt; pstack m ==&gt; s ~&gt; pstack m * s ~&gt; pstack m
</p>
</div>
</div>
<div id="outline-container-org9f9acff" class="outline-3">
<h3 id="org9f9acff">Recursive Ownership of Elements</h3>
<div class="outline-text-3" id="text-org9f9acff">
<p>
Currently in Gospel, we have to way of describing recursive ownership
of data structures with mutable elements.
</p>
</div>
<div id="outline-container-org24fd322" class="outline-4">
<h4 id="org24fd322">The Problem</h4>
<div class="outline-text-4" id="text-org24fd322">
<p>
If we wished to specify, for example, a stack where its elements could
be impure, we would like to have a <b>Gospel</b> specification such as:
</p>
<pre class="example" id="org6bed084">
type 'a t
(*@ model : 'a sequence *)

val peek : 'a t -&gt; 'a
(*@ r = pop q
    requires q &lt;&gt; empty
    preserves q @ 'a t
    produces r @ 'a
    ensures r = hd q *)
</pre>

<p>
If we assume that <code>'a</code> can be a mutable value, then our translation into
Separation Logic should look like:
</p>
<pre class="example" id="org4550cd6">
Parameter Stack : {A} {B} `{Enc A} (l : loc)
              (HO: A -&gt; B -&gt; hprop) (model : sequence A).

Parameter peek_spec :
forall A `{Enc A} q_loc HO q,
PRE(Stack q_loc HO q)
CODE(peek s)
POST(r_loc =&gt; exists r,
       HO r_loc r * Stack q_loc HO q * \[hd q = r])           
</pre>
<p>
Although this makes intuitive sense, it is unsound, seeing as we are
duplicating the permission for the value stored in <code>r_loc</code>.
</p>
</div>
</div>

<div id="outline-container-orgd0ab239" class="outline-4">
<h4 id="orgd0ab239">Magic Wand (in Gospel)</h4>
<div class="outline-text-4" id="text-orgd0ab239">
<p>
There are a few possibilities to circumvent this issue. The most
obvious is using the magic wand: in the Gospel spec we could have
something along the lines of:
</p>
<pre class="example" id="orgdcfcb75">
val get : 'a ref -&gt; 'a
(*@ v = get r
    consumes r @ 'a t
    produces v @ 'a
    produces r @ val t until r *)
</pre>
<p>
The final <code>produces</code> clause would mean, intuitively, that we return <code>q</code>
with no ownership of its elements. The <code>until</code> operator(?) signifies
that when ownership of <code>r</code>, as described in the first <code>produces</code> clause,
has been surrendered we regain ownership of <code>q</code> as is described in the
<code>consumes</code> clause. The post condition of the previous specification
would now look something like:
</p>
<pre class="example" id="orga59e072">
forall A `{Enc A} q_loc HO q,
POST(r_loc =&gt; exists r,
       HO r_loc r * Stack q_loc val q * \[hd q = r] *
       (HO r_loc r *-&gt; Stack q_loc HO q)
       )
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org92611aa" class="outline-2">
<h2 id="org92611aa">Exceptional Specifications</h2>
<div class="outline-text-2" id="text-org92611aa">
<p>
With the addition of ownership clauses in <b>Gospel</b>, we also need a way
of describing ownership in cases of exceptional termination. The
simplest (and indeed the most common case) is when we return full
ownership of the data structure.
</p>
<pre class="example" id="org4a27079">
val pop : 'a t -&gt; 'a
(*@ r = pop p
    modifies p
    raises Not_found begin
      produces p
      ensures p = old p = empty
    end
    ensures r = hd (old p)
    ensures p = tl (old p) *)
</pre>
</div>
<div id="outline-container-orgfe4fa20" class="outline-3">
<h3 id="orgfe4fa20">Problems with ownership clauses</h3>
<div class="outline-text-3" id="text-orgfe4fa20">
<p>
In the nested specification, we state that we return full ownership of
<code>p</code> as well as stating that <code>p</code> is unchanged and is equal to the <code>empty</code>
sequence. Since this is an exceptional condition, <code>ensures</code> and <code>produces</code>
are the only clauses that make sense to use. A few things about this
specification are not ideal. Specifically, having to explicitly write
<code>produces</code> and that the data structure is not modified can be a bit
heavy. There are a few possible way to remedy this, none of them are
fully satisfying:
</p>

<ul class="org-ul">
<li>We could allow the use of the <code>preserves</code> clause within exceptional
postconditions and assume it to be the default. This is not ideal
since <code>preserves</code> is syntactic sugar for a <code>produces</code> and a <code>consumes</code> and
as I have stated, it does not make sense to have a <code>produces</code> within
exceptional postconditions. We could have it so a <code>preserves</code> clause
has a different semantics when used within an exceptional
specification. From a user perspective this is not that bad since it
is an intuitive use of the <code>preserves</code> clause. However, having it mean
something different based on context makes the semantics a bit
messy. (The more I think about this, the more I prefer this
solution. Although this means that the desugaring of <code>preserves</code> is
context dependent, it makes intuitive sense and does not break
things in a fundemental way).</li>

<li>We could have a default which states that if no ownership clause is
given then we assume we return the same ownership that we receive,
that is, the exceptional <code>produces</code> clause is the same as the
non-exceptional <code>consumes</code> clause. Additionally, we would also assume
an ensures clause stating that the variable is unchanged. This is
also not ideal because it would make it so <code>produces</code> clauses of
exceptional specifications have a different default than</li>

<li>We could have a default that if no ownership clause is given then we
assume the non-exceptional <code>produces</code> clause.</li>
</ul>
</div>
</div>

<div id="outline-container-org613bc6b" class="outline-3">
<h3 id="org613bc6b">Changes to the Gospel syntax</h3>
<div class="outline-text-3" id="text-org613bc6b">
<p>
There are now three ways to write exceptional postconditions:
</p>
<ul class="org-ul">
<li><p>
A list comma separated identifiers
</p>
<pre class="example" id="org0c65556">
raises E1, E2, E3
</pre></li>
<li><p>
A nested specification where the only valid clauses are <code>produces</code> and
<code>ensures</code>. The values <code>x1 x2 ...</code> are the exception's arguments,
these may be omitted.
</p>
<pre class="example" id="orgbce711c">
raises E (x1, x2 ..) begin
  produces ...
  ensures ...
end
</pre></li>
<li><p>
A single exceptional postcondition.
</p>
<pre class="example" id="org1241b6f">
raises E (x1, x2, ...) -&gt; P
</pre>
<p>
Which is just sugar for
</p>
<pre class="example" id="org5510a65">
raises E (x1, x2 ...) begin
  ensures P
end
</pre></li>
</ul>
<p>
In the latter two cases , all exceptional return values have to be named
(i.e.) no wildcards are allowed, similar to what <b>Gospel</b> requires with
regards to normal return values (either they are all named or none are
named).
</p>
</div>
</div>
</div>

<div id="outline-container-orgaa7af05" class="outline-2">
<h2 id="orgaa7af05">Functor Constraints</h2>
<div class="outline-text-2" id="text-orgaa7af05">
<p>
Just like we can add constraints to <b>OCaml</b> functor applications, we
should also be allowed to add additional <b>Gospel</b> constraints. For
example:
</p>
<pre class="example" id="orgf95cab6">
module Make 
  (H : HashedType)
  (S : SENTINELS with type t = H.t)
  : SET with type element = H.t
  (*@ with predicate equiv = H.equiv and
           function  tomb = S.tomb   and
           function  void = S.void 
           *)
</pre>
</div>
</div>
<div id="outline-container-orgfe9fd3e" class="outline-2">
<h2 id="orgfe9fd3e">Miscellaneous changes</h2>
<div class="outline-text-2" id="text-orgfe9fd3e">
<p>
Section for minor changes I made in Gospel that aren't relevant for
other sections.
</p>
</div>

<div id="outline-container-orga07628e" class="outline-3">
<h3 id="orga07628e"><code>old</code> in Gospel function specifications</h3>
<div class="outline-text-3" id="text-orga07628e">
<p>
In <b>Gospel</b> we can use the <code>old</code> constructor in the specification of
logical functions specifications. In my opinion, this should not be
allowed since there is no practical reason to talk about the "old"
version of a variable that is never modified.
</p>
</div>
</div>
</div>

<div id="outline-container-org761509f" class="outline-2">
<h2 id="org761509f">Updated syntax</h2>
<div class="outline-text-2" id="text-org761509f">
<p>
In Gospel there is no way to talk about ownership of values when an
exception is raised. To this end, we propose an updated syntax to
allow users to write multiple specifications for each possible raised
exception. 
</p>

<p>
Currently, Gospel specifications start with a header where we define
the names of the arguments and return values, which is then followed
up with pre and postconditions and other clauses. Our proposal is to
have an alternate syntax where the header appears <i>after</i> clauses that
describe the program state before the function is called (<code>requires</code>,
<code>consumes</code>, etc) and before clauses that describe the state after the
function returns. For example, the specification for a <code>pop</code> function of
a queue would be written as:
</p>
<pre class="example" id="orge8e6349">
val pop : 'a queue -&gt; 'a
(*@ requires not (empty q)
    consumes q
    let x = pop q
    produces q
    ensures x :: q = old q *)
</pre>
<p>
In the case of a function that may raise some exception, we would use
a <code>match</code> to describe its behavior in the normal case and the
exceptional case. For example, if we wish to describe the <code>pop</code> function
without using the precondition <code>not (empty q)</code> and instead with an
exceptional postcondition.
</p>
<pre class="example" id="org1b7dca0">
val pop : 'a queue -&gt; 'a
(*@ consumes q
    match find q p with
    |exception Not_found -&gt;
       produces q
       ensures p = old p = Sequence.empty
    |r -&gt;
       produces q
       ensures x :: q = old q *)
</pre>
<p>
One weakness of this syntax is that there is not an obvious location
where we should place <code>modifies</code> clauses, seeing as this is just
syntactic sugar for a <code>consumes</code> and a <code>produces</code> clause. We propose that
users should be allowed to place <code>modifies</code> clause either before the
function call or after in a non exceptional branch. Thus, the
specification for <code>pop</code> could be rewritten as:
</p>
<pre class="example" id="org907a1d1">
val pop : 'a queue -&gt; 'a
(*@ modifies q
    match find q p with
    |exception Not_found -&gt;
       ensures p = old p = Sequence.empty
    |r -&gt;
       produces q
       ensures x :: q = old q *)
</pre>
<p>
Another weakness of this representation is that the function's
arguments are used before they are named in the function
call. 
</p>

<p>
We believe that this updated syntax can coexist with the current
Gospel syntax and we should let users choose whichever they
prefer/need. 
</p>

<p>
Note: We didn't discuss if the current Gospel syntax for exceptional
postconditions should be maintained. For example, could we write 
</p>
<pre class="example" id="orgbbc4406">
raises Not_found -&gt; p = old p = Sequence.empty
</pre>
<p>
If so, what should the semantics for this clause be?
</p>
</div>
</div>

<div id="outline-container-org2a054f1" class="outline-2">
<h2 id="org2a054f1">Shared Resources</h2>
<div class="outline-text-2" id="text-org2a054f1">
<p>
There is currently no way of capturing shared permissions in Gospel,
all values are exclusively owned by the functions that use them. To
solve this, we could take inspiration from the <a href="https://dl.acm.org/doi/10.1145/3622798">Leaf</a> library and add a
notion of resources guarding other resources.
</p>

<p>
In Leaf, the authors introduce the ⤔ operator where G ⤔ P means that
the resource G guards the resource P. In other words, we can exchange
exclusive ownership of resource G to obtain shared ownership of a
resource G. 
</p>
</div>


<div id="outline-container-orgd4daa20" class="outline-3">
<h3 id="orgd4daa20">Mutex example (monomorphic)</h3>
<div class="outline-text-3" id="text-orgd4daa20">
<p>
Specification for a mutually exclusive lock that protects a single
reference.
</p>
<pre class="example" id="org49df263">
type mutex
(*@ model protectee : loc *)

val create : unit -&gt; mutex
(*@ consumes s @ int ref
    create [s : int ref] *)

val lock : mutex -&gt; unit
(*@ lock m
    produces m @ acquired (* not strictly nec*)
    produces m.protectee @ int ref *)

val unlock : mutex -&gt; unit
(*@ consumes m.protectee @ int ref
    consumes m @ acquired
    unlock m *)

val try_lock : mutex -&gt; bool
(*@ let b = lock m in
    produces b -&gt; m.protectee @ int ref *)
</pre>
</div>
</div>
<div id="outline-container-org1d9655c" class="outline-3">
<h3 id="org1d9655c">Mutex example</h3>
<div class="outline-text-3" id="text-org1d9655c">
<pre class="example" id="orgdb090c0">
type (*@ 's *) mutex

(*@ affine lens acquired (m : 's mutex) *)

val create : unit -&gt; (*@ 's *) mutex
(*@ consumes 's
    create () *)

val lock : (*@ 's *) mutex -&gt; unit
(*@ lock m
    produces 's *)

val unlock : (*@ 's *) mutex -&gt; unit
(*@ consumes 's
    unlock m *)

val try_lock : (*@ 's *) mutex -&gt; bool
(*@ try_lock m
    produces b -&gt; 's *)
</pre>
</div>
</div>
<div id="outline-container-org86b20b5" class="outline-3">
<h3 id="org86b20b5">Explicitly guarded mutex</h3>
<div class="outline-text-3" id="text-org86b20b5">
<pre class="example" id="orgffbf2c7">
type 'a mutex

type 'a guard
(*@ ephemeral *)

val create : 'a -&gt; 'a mutex
(*@ consumes s 
    create s *)

val lock : 'a mutex -&gt; 'a guard
(*@ g = lock m *)

val unlock : 'a guard -&gt; unit
(*@ consumes g @ 'a guard
    unlock g *)

val peek : 'a guard -&gt; 'a
(*@ s = peek g
    produces g @ 'a guard &lt;-&gt; s @ 'a *)
</pre>
</div>
</div>
<div id="outline-container-org6286e23" class="outline-3">
<h3 id="org6286e23">Explicitly guarded mutex v2</h3>
<div class="outline-text-3" id="text-org6286e23">
<pre class="example" id="orgb54cda9">
type 'a mutex

type 'a guard

val create : 'a -&gt; 'a mutex
(*@ consumes s 
    create s *)

val lock : 'a mutex -&gt; 'a guard
(*@ g = lock m *)

val unlock : 'a guard -&gt; unit
(*@ consumes l @ 'a guard
    unlock l *)

val peek : 'a guard -&gt; 'a
(*@ s = peek g
    produces g @ 'a guard == s @ 'a *)

val try_lock : (*@ 's *) mutex -&gt; bool
(*@ try_lock m
    produces b -&gt; 's *)
</pre>
</div>
</div>
<div id="outline-container-org142fb3a" class="outline-3">
<h3 id="org142fb3a">Shared Lock</h3>
<div class="outline-text-3" id="text-org142fb3a">
<pre class="example" id="orga6d41f1">
type (*@ 'a *) rw_lock
(*@ ephemeral *)

(*@ type 'a exc
    ephemeral
    model m : loc
    model state : 'a *)

(*@ type 'a sh
    guards : 'a
    model m : loc
    model state : 'a *)

val rwlock_new : unit -&gt; (*@ 'a *) rw_lock
(*@ consumes s
    create [s : 'a] *)

val rwlock_free : (*@ 'a *) rw_lock -&gt; unit
(*@ consumes m
    rwlock_free m *)

val lock_exc : (*@ 'a *) rw_lock -&gt; unit
(*@ guarded  m
    let [e : exc] = lock m in
    produces e @ 'a exc
    ensures e.m = &amp;m *)

val unlock_exc : (*@ 'a *) rw_lock -&gt; unit
(*@ guarded m
    requires e.m = &amp;m
    consumes e @ 'a exc
    unlock [e : exc] m *)

val lock_shared : (*@ 'a *) rw_lock -&gt; unit
(*@ guarded m
    let [e : sh] = lock m in
    produces e @ 'a exc
    ensures e.m = &amp;m *)

val unlock_shared : (*@ 'a *) rw_lock -&gt; unit
(*@ guarded m
    requires e.m = &amp;m
    consumes e @ 'a exc
    let () = unlock [e : exc] m *)
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 29.3 (<a href="https://orgmode.org">Org</a> mode 9.6.15)</p>
</div>
</body>
</html>
